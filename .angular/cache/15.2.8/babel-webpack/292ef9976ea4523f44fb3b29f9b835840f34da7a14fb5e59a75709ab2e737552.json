{"ast":null,"code":"import _asyncToGenerator from \"/Users/darelvaleros/ibm workspace/development/agrilife/ble/agrilife-pwa/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, InjectionToken, NgModule } from '@angular/core';\nimport { from, throwError, fromEvent } from 'rxjs';\nimport { filter, mergeMap, map, takeUntil } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\nlet BrowserWebBluetooth = /*#__PURE__*/(() => {\n  class BrowserWebBluetooth {\n    constructor() {\n      this.ble = navigator.bluetooth;\n      if (!this.ble) {\n        throw new Error('Your browser does not support Smart Bluetooth. See http://caniuse.com/#search=Bluetooth for more details.');\n      }\n    }\n    requestDevice(options) {\n      return this.ble.requestDevice(options);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */BrowserWebBluetooth.ɵfac = function BrowserWebBluetooth_Factory(t) {\n    return new (t || BrowserWebBluetooth)();\n  };\n  BrowserWebBluetooth.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BrowserWebBluetooth,\n    factory: BrowserWebBluetooth.ɵfac\n  });\n  return BrowserWebBluetooth;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ServerWebBluetooth = /*#__PURE__*/(() => {\n  class ServerWebBluetooth {\n    static instance() {\n      // mocked object for now\n      return {};\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */ServerWebBluetooth.ɵfac = function ServerWebBluetooth_Factory(t) {\n    return new (t || ServerWebBluetooth)();\n  };\n  ServerWebBluetooth.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ServerWebBluetooth,\n    factory: ServerWebBluetooth.ɵfac\n  });\n  return ServerWebBluetooth;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ConsoleLoggerService = /*#__PURE__*/(() => {\n  class ConsoleLoggerService {\n    log(...args) {\n      console.log.apply(console, args);\n    }\n    error(...args) {\n      console.error.apply(console, args);\n    }\n    warn(...args) {\n      console.warn.apply(console, args);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */ConsoleLoggerService.ɵfac = function ConsoleLoggerService_Factory(t) {\n    return new (t || ConsoleLoggerService)();\n  };\n  ConsoleLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ConsoleLoggerService,\n    factory: ConsoleLoggerService.ɵfac,\n    providedIn: 'root'\n  });\n  return ConsoleLoggerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NoLoggerService = /*#__PURE__*/(() => {\n  class NoLoggerService {\n    log(...args) {}\n    error(...args) {}\n    warn(...args) {}\n  }\n  /** @nocollapse */\n  /** @nocollapse */NoLoggerService.ɵfac = function NoLoggerService_Factory(t) {\n    return new (t || NoLoggerService)();\n  };\n  NoLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NoLoggerService,\n    factory: NoLoggerService.ɵfac,\n    providedIn: 'root'\n  });\n  return NoLoggerService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BluetoothCore = /*#__PURE__*/(() => {\n  class BluetoothCore {\n    constructor(webBle, console) {\n      this.webBle = webBle;\n      this.console = console;\n      this.device$ = new EventEmitter();\n      this.gatt$ = new EventEmitter();\n      this.characteristicValueChanges$ = new EventEmitter();\n      this.gattServer = null;\n    }\n    getDevice$() {\n      return this.device$;\n    }\n    getGATT$() {\n      return this.gatt$;\n    }\n    streamValues$() {\n      return this.characteristicValueChanges$.pipe(filter(value => value && value.byteLength > 0));\n    }\n    /**\n     * Run the discovery process and read the value form the provided service and characteristic\n     * @param options the ReadValueOptions\n     */\n    value(options) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        _this.console.log('[BLE::Info] Reading value with options %o', options);\n        if (typeof options.acceptAllDevices === 'undefined') {\n          options.acceptAllDevices = true;\n        }\n        if (typeof options.optionalServices === 'undefined') {\n          options.optionalServices = [options.service];\n        } else {\n          options.optionalServices = [...options.optionalServices];\n        }\n        _this.console.log('[BLE::Info] Reading value with options %o', options);\n        try {\n          const device = yield _this.discover({\n            acceptAllDevices: options.acceptAllDevices,\n            optionalServices: options.optionalServices\n          });\n          _this.console.log('[BLE::Info] Device info %o', device);\n          const gatt = yield _this.connectDevice(device);\n          _this.console.log('[BLE::Info] GATT info %o', gatt);\n          const primaryService = yield _this.getPrimaryService(gatt, options.service);\n          _this.console.log('[BLE::Info] Primary Service info %o', primaryService);\n          const characteristic = yield _this.getCharacteristic(primaryService, options.characteristic);\n          _this.console.log('[BLE::Info] Characteristic info %o', characteristic);\n          const value = yield characteristic.readValue();\n          _this.console.log('[BLE::Info] Value info %o', value);\n          return value;\n        } catch (error) {\n          throw new Error(error);\n        }\n      })();\n    }\n    value$(options) {\n      return from(this.value(options));\n    }\n    /**\n     * Run the discovery process.\n     *\n     * @param Options such as filters and optional services\n     * @return  The GATT server for the chosen device\n     */\n    discover(options = {}) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        options.optionalServices = options.optionalServices || ['generic_access'];\n        _this2.console.log('[BLE::Info] Requesting devices with options %o', options);\n        let device = null;\n        try {\n          device = yield _this2.webBle.requestDevice(options);\n          device.addEventListener('gattserverdisconnected', _this2.onDeviceDisconnected.bind(_this2));\n          if (device) {\n            _this2.device$.emit(device);\n          } else {\n            _this2.device$.error(`[BLE::Error] Can not get the Bluetooth Remote GATT Server. Abort.`);\n          }\n        } catch (error) {\n          _this2.console.error(error);\n        }\n        return device;\n      })();\n    }\n    /**\n     * This handler will trigger when the client disconnets from the server.\n     *\n     * @param event The onDeviceDisconnected event\n     */\n    onDeviceDisconnected(event) {\n      const disconnectedDevice = event.target;\n      this.console.log('[BLE::Info] disconnected device %o', disconnectedDevice);\n      this.device$.emit(null);\n    }\n    /**\n     * Run the discovery process.\n     *\n     * @param Options such as filters and optional services\n     * @return  Emites the value of the requested service read from the device\n     */\n    discover$(options) {\n      return from(this.discover(options)).pipe(mergeMap(device => this.connectDevice$(device)));\n    }\n    /**\n     * Connect to current device.\n     *\n     * @return  Emites the gatt server instance of the requested device\n     */\n    connectDevice(device) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (device) {\n          _this3.console.log('[BLE::Info] Connecting to Bluetooth Remote GATT Server of %o', device);\n          try {\n            const gattServer = yield device.gatt.connect();\n            _this3.gattServer = gattServer;\n            _this3.gatt$.emit(gattServer);\n            return gattServer;\n          } catch (error) {\n            // probably the user has canceled the discovery\n            Promise.reject(`${error.message}`);\n            _this3.gatt$.error(`${error.message}`);\n          }\n        } else {\n          _this3.console.error('[BLE::Error] Was not able to connect to Bluetooth Remote GATT Server');\n          _this3.gatt$.error(null);\n        }\n      })();\n    }\n    /**\n     * Connect to current device.\n     *\n     * @return  Emites the gatt server instance of the requested device\n     */\n    connectDevice$(device) {\n      return from(this.connectDevice(device));\n    }\n    /**\n     * Disconnect the current connected device\n     */\n    disconnectDevice() {\n      if (!this.gattServer) {\n        return;\n      }\n      this.console.log('[BLE::Info] Disconnecting from Bluetooth Device %o', this.gattServer);\n      if (this.gattServer.connected) {\n        this.gattServer.disconnect();\n      } else {\n        this.console.log('[BLE::Info] Bluetooth device is already disconnected');\n      }\n    }\n    /**\n     * Requests the primary service.\n     *\n     * @param gatt The BluetoothRemoteGATTServer sever\n     * @param service The UUID of the primary service\n     * @return The remote service (as a Promise)\n     */\n    getPrimaryService(gatt, service) {\n      return _asyncToGenerator(function* () {\n        try {\n          const remoteService = yield gatt.getPrimaryService(service);\n          return yield Promise.resolve(remoteService);\n        } catch (error) {\n          return yield Promise.reject(`${error.message} (${service})`);\n        }\n      })();\n    }\n    /**\n     * Requests the primary service.\n     *\n     * @param gatt The BluetoothRemoteGATTServer sever\n     * @param service The UUID of the primary service\n     * @return The remote service (as an observable).\n     */\n    getPrimaryService$(gatt, service) {\n      this.console.log('[BLE::Info] Getting primary service \"%s\" (if available) of %o', service, gatt);\n      if (gatt) {\n        return from(this.getPrimaryService(gatt, service));\n      } else {\n        return throwError(new Error('[BLE::Error] Was not able to connect to the Bluetooth Remote GATT Server'));\n      }\n    }\n    /**\n     * Requests a characteristic from the primary service.\n     *\n     * @param primaryService The primary service.\n     * @param characteristic The characteristic's UUID.\n     * @returns The characteristic description (as a Promise).\n     */\n    getCharacteristic(primaryService, characteristic) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        _this4.console.log('[BLE::Info] Getting Characteristic \"%s\" of %o', characteristic, primaryService);\n        try {\n          const char = yield primaryService.getCharacteristic(characteristic);\n          // listen for characteristic value changes\n          if (char.properties.notify) {\n            char.startNotifications().then(_ => {\n              _this4.console.log('[BLE::Info] Starting notifications of \"%s\"', characteristic);\n              char.addEventListener('characteristicvaluechanged', _this4.onCharacteristicChanged.bind(_this4));\n            }, error => {\n              Promise.reject(`${error.message} (${characteristic})`);\n            });\n          } else {\n            char.addEventListener('characteristicvaluechanged', _this4.onCharacteristicChanged.bind(_this4));\n          }\n          return char;\n        } catch (rejectionError) {\n          Promise.reject(`${rejectionError.message} (${characteristic})`);\n        }\n      })();\n    }\n    /**\n     * Requests a characteristic from the primary service.\n     *\n     * @param primaryService The primary service.\n     * @param characteristic The characteristic's UUID.\n     * @returns The characteristic description (as a Observable).\n     */\n    getCharacteristic$(primaryService, characteristic) {\n      this.console.log('[BLE::Info] Getting Characteristic \"%s\" of %o', characteristic, primaryService);\n      return from(this.getCharacteristic(primaryService, characteristic));\n    }\n    /**\n     * Sets the characteristic's state.\n     *\n     * @param service The parent service of the characteristic.\n     * @param characteristic The requested characteristic\n     * @param state An ArrayBuffer containing the value of the characteristic.\n     * @return The primary service (useful for chaining).\n     */\n    setCharacteristicState(service, characteristic, state) {\n      const primaryService = this.getPrimaryService$(this.gattServer, service);\n      primaryService\n      // tslint:disable-next-line: variable-name\n      .pipe(mergeMap(_primaryService => this.getCharacteristic$(_primaryService, characteristic)))\n      // tslint:disable-next-line: no-shadowed-variable\n      .subscribe(characteristic => this.writeValue$(characteristic, state));\n      return primaryService;\n    }\n    /**\n     * Enables the specified characteristic of a given service.\n     *\n     * @param service The parent service of the characteristic.\n     * @param characteristic The requested characteristic\n     * @return The primary service (useful for chaining).\n     */\n    enableCharacteristic(service, characteristic, state) {\n      state = state || new Uint8Array([1]);\n      return this.setCharacteristicState(service, characteristic, state);\n    }\n    /**\n     * Disables the specified characteristic of a given service.\n     *\n     * @param service The parent service of the characteristic.\n     * @param characteristic The requested characteristic.\n     * @return The primary service (useful for chaining).\n     */\n    disbaleCharacteristic(service, characteristic, state) {\n      state = state || new Uint8Array([0]);\n      return this.setCharacteristicState(service, characteristic, state);\n    }\n    /**\n     * Dispatches new values emitted by a characteristic.\n     *\n     * @param event the distpatched event.\n     */\n    onCharacteristicChanged(event) {\n      this.console.log('[BLE::Info] Dispatching new characteristic value %o', event);\n      const value = event.target.value;\n      this.characteristicValueChanges$.emit(value);\n    }\n    /**\n     * Reads a value from the characteristics, as a DataView.\n     *\n     * @param characteristic The requested characteristic.\n     * @return the DataView value (as an Observable).\n     */\n    readValue$(characteristic) {\n      this.console.log('[BLE::Info] Reading Characteristic %o', characteristic);\n      return from(characteristic.readValue().then(data => Promise.resolve(data), error => Promise.reject(`${error.message}`)));\n    }\n    /**\n     * Writes a value into the specified characteristic.\n     *\n     * @param characteristic The requested characteristic.\n     * @param value The value to be written (as an ArrayBuffer or Uint8Array).\n     * @return an void Observable.\n     */\n    writeValue$(characteristic, value) {\n      this.console.log('[BLE::Info] Writing Characteristic %o', characteristic);\n      return from(characteristic.writeValue(value).then(_ => Promise.resolve(), error => Promise.reject(`${error.message}`)));\n    }\n    /**\n     * A stream of DataView values emitted by the specified characteristic.\n     *\n     * @param characteristic The characteristic which value you want to observe\n     * @return The stream of DataView values.\n     */\n    observeValue$(characteristic) {\n      characteristic.startNotifications();\n      const disconnected = fromEvent(characteristic.service.device, 'gattserverdisconnected');\n      return fromEvent(characteristic, 'characteristicvaluechanged').pipe(map(event => event.target.value), takeUntil(disconnected));\n    }\n    /**\n     * A utility method to convert LE to an unsigned 16-bit integer values.\n     *\n     * @param data The DataView binary data.\n     * @param byteOffset The offset, in byte, from the start of the view where to read the data.\n     * @return An unsigned 16-bit integer number.\n     */\n    littleEndianToUint16(data, byteOffset) {\n      // tslint:disable-next-line:no-bitwise\n      return (this.littleEndianToUint8(data, byteOffset + 1) << 8) + this.littleEndianToUint8(data, byteOffset);\n    }\n    /**\n     * A utility method to convert LE to an unsigned 8-bit integer values.\n     *\n     * @param data The DataView binary data.\n     * @param byteOffset The offset, in byte, from the start of the view where to read the data.\n     * @return An unsigned 8-bit integer number.\n     */\n    littleEndianToUint8(data, byteOffset) {\n      return data.getUint8(byteOffset);\n    }\n    /**\n     * Sends random data (for testing purposes only).\n     *\n     * @return Random unsigned 8-bit integer values.\n     */\n    fakeNext(fakeValue) {\n      if (fakeValue === undefined) {\n        fakeValue = () => {\n          const dv = new DataView(new ArrayBuffer(8));\n          // tslint:disable-next-line:no-bitwise\n          dv.setUint8(0, Math.random() * 110 | 0);\n          return dv;\n        };\n      }\n      this.characteristicValueChanges$.emit(fakeValue());\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */BluetoothCore.ɵfac = function BluetoothCore_Factory(t) {\n    return new (t || BluetoothCore)(i0.ɵɵinject(BrowserWebBluetooth), i0.ɵɵinject(ConsoleLoggerService));\n  };\n  BluetoothCore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: BluetoothCore,\n    factory: BluetoothCore.ɵfac,\n    providedIn: 'root'\n  });\n  return BluetoothCore;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction browserWebBluetooth() {\n  return new BrowserWebBluetooth();\n}\nfunction consoleLoggerServiceConfig(options) {\n  if (options && options.enableTracing) {\n    return new ConsoleLoggerService();\n  } else {\n    return new NoLoggerService();\n  }\n}\nfunction makeMeTokenInjector() {\n  return new InjectionToken('AWBOptions');\n}\nlet WebBluetoothModule = /*#__PURE__*/(() => {\n  class WebBluetoothModule {\n    static forRoot(options = {}) {\n      return {\n        ngModule: WebBluetoothModule,\n        providers: [BluetoothCore, {\n          provide: BrowserWebBluetooth,\n          useFactory: browserWebBluetooth\n        }, {\n          provide: makeMeTokenInjector,\n          useValue: options\n        }, {\n          provide: ConsoleLoggerService,\n          useFactory: consoleLoggerServiceConfig,\n          deps: [makeMeTokenInjector]\n        }]\n      };\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */WebBluetoothModule.ɵfac = function WebBluetoothModule_Factory(t) {\n    return new (t || WebBluetoothModule)();\n  };\n  WebBluetoothModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: WebBluetoothModule\n  });\n  WebBluetoothModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return WebBluetoothModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// http://processors.wiki.ti.com/images/a/a8/BLE_SensorTag_GATT_Server.pdf\n// prettier-ignore\nconst TiTag = {\n  DEVICE_INFORMATION: {\n    SERVICE: 'f000180a-0451-4000-b000-000000000000',\n    SYSTEM_ID: 'f0002a23-0451-4000-b000-000000000000',\n    MODEL_NUMBER: 'f0002a24-0451-4000-b000-000000000000',\n    SERIAL_NUMBER: 'f0002a25-0451-4000-b000-000000000000',\n    FIRMWARE_REV: 'f0002a26-0451-4000-b000-000000000000',\n    HARDWARE_REV: 'f0002a27-0451-4000-b000-000000000000',\n    SOFTWARE_REV: 'f0002a28-0451-4000-b000-000000000000',\n    MANIFACTURER: 'f0002a29-0451-4000-b000-000000000000',\n    IEEE11073: 'f0002a2a-0451-4000-b000-000000000000',\n    PNP_ID: 'f0002a50-0451-4000-b000-000000000000'\n  },\n  BATTERY: {\n    SERVICE: 'f000180f-0451-4000-b000-000000000000',\n    LEVEL: 'f0002a19-0451-4000-b000-000000000000'\n  },\n  TEMPERATURE: {\n    SERVICE: 'f000aa00-0451-4000-b000-000000000000',\n    DATA: 'f000aa01-0451-4000-b000-000000000000',\n    CONFIGURATION: 'f000aa02-0451-4000-b000-000000000000',\n    PERIOD: 'f000aa03-0451-4000-b000-000000000000'\n  },\n  HUMIDITY: {\n    SERVICE: 'f000aa20-0451-4000-b000-000000000000',\n    DATA: 'f000aa21-0451-4000-b000-000000000000',\n    CONFIGURATION: 'f000aa22-0451-4000-b000-000000000000',\n    PERIOD: 'f000aa23-0451-4000-b000-000000000000'\n  },\n  BAROMETER: {\n    SERVICE: 'f000aa40-0451-4000-b000-000000000000',\n    DATA: 'f000aa41-0451-4000-b000-000000000000',\n    CONFIGURATION: 'f000aa42-0451-4000-b000-000000000000',\n    PERIOD: 'f000aa44-0451-4000-b000-000000000000'\n  },\n  // service not available in model CC2650\n  // ACCELEROMETER : {\n  //   SERVICE :                 'f000aa10-0451-4000-b000-000000000000',\n  //   DATA :                    'f000aa11-0451-4000-b000-000000000000',\n  //   CONFIGURATION :           'f000aa12-0451-4000-b000-000000000000',\n  //   PERIOD :                  'f000aa13-0451-4000-b000-000000000000'\n  // },\n  // service not available in model CC2650\n  // MAGNETOMETER : {\n  //   SERVICE :                 'f000aa30-0451-4000-b000-000000000000',\n  //   DATA :                    'f000aa31-0451-4000-b000-000000000000',\n  //   CONFIGURATION :           'f000aa32-0451-4000-b000-000000000000',\n  //   PERIOD :                  'f000aa33-0451-4000-b000-000000000000'\n  // },\n  // service not available in model CC2650\n  // GYROSCOPE : {\n  //   SERVICE :                 'f000aa50-0451-4000-b000-000000000000',\n  //   DATA :                    'f000aa51-0451-4000-b000-000000000000',\n  //   CONFIGURATION :           'f000aa52-0451-4000-b000-000000000000',\n  //   PERIOD :                  'f000aa53-0451-4000-b000-000000000000'\n  // },\n  MOVEMENT: {\n    SERVICE: 'f000aa80-0451-4000-b000-000000000000',\n    DATA: 'f000aa81-0451-4000-b000-000000000000',\n    CONFIGURATION: 'f000aa82-0451-4000-b000-000000000000',\n    PERIOD: 'f000aa83-0451-4000-b000-000000000000'\n  },\n  LIGHT: {\n    SERVICE: 'f000aa70-0451-4000-b000-000000000000',\n    DATA: 'f000aa71-0451-4000-b000-000000000000',\n    CONFIGURATION: 'f000aa72-0451-4000-b000-000000000000',\n    PERIOD: 'f000aa73-0451-4000-b000-000000000000'\n  },\n  KEYPRESS: {\n    SERVICE: 'f000ffe0-0451-4000-b000-000000000000',\n    STATE: 'f000ffe1-0451-4000-b000-000000000000'\n  },\n  __REGISTER__: {\n    SERVICE: 'f000ac00-0451-4000-b000-000000000000',\n    DATA: 'f000ac01-0451-4000-b000-000000000000',\n    ADDRESS: 'f000ac02-0451-4000-b000-000000000000',\n    DEVICE_ID: 'f000ac03-0451-4000-b000-000000000000'\n  },\n  CONTROL: {\n    SERVICE: 'f000ccc0-0451-4000-b000-000000000000',\n    CURRENT_USED_PARAMETERS: 'f000ccc1-0451-4000-b000-000000000000',\n    REQUEST_NEW_PARAMETERS: 'f000ccc2-0451-4000-b000-000000000000',\n    DISCONNECT_REQUEST: 'f000ccc3-0451-4000-b000-000000000000'\n  },\n  OAD: {\n    SERVICE: 'f000ffc0-0451-4000-b000-000000000000',\n    IMAGE_NOTIFY: 'f000ffc1-0451-4000-b000-000000000000',\n    IMAGE_BLOCK_REQUEST: 'f000ffc2-0451-4000-b000-000000000000',\n    IMAGE_COUNT: 'f000ffc3-0451-4000-b000-000000000000',\n    IMAGE_STATUS: 'f000ffc4-0451-4000-b000-000000000000'\n  },\n  IO: {\n    SERVICE: 'f000aa64-0451-4000-b000-000000000000',\n    DATA: 'f000aa65-0451-4000-b000-000000000000',\n    CONFIG: 'f000aa66-0451-4000-b000-000000000000'\n  }\n};\nconst TI_SENSORAG_SERVICES = Object.keys(TiTag).map(key => TiTag[key].SERVICE);\n\n/*\n * Fake Web Bluetooth implementation\n * Replace real browser Bluetooth objects by a much simpler objects that implement some required functionalities\n */\nclass FakeBluetoothDevice {\n  constructor(id, name) {\n    this.id = id;\n    this.name = name;\n    this.listeners = {\n      gattserverdisconnected: []\n    };\n  }\n  addEventListener(type, listener) {\n    this.listeners[type] = [...this.listeners[type], listener];\n  }\n  disconnect() {\n    const mockedEvent = {\n      target: this\n    };\n    this.listeners.gattserverdisconnected.forEach(listener => listener(mockedEvent));\n  }\n  clear() {\n    this.id = undefined;\n    this.name = undefined;\n    this.listeners = {\n      gattserverdisconnected: []\n    };\n  }\n}\nclass FakeBluetoothRemoteGATTServer {\n  constructor(device, services) {\n    this.device = device;\n    this.services = services;\n    this.connected = false;\n    device.gatt = this;\n  }\n  connect() {\n    this.connected = true;\n    return Promise.resolve(this);\n  }\n  getPrimaryService(service) {\n    return Promise.resolve(this.services[service].service);\n  }\n  disconnect() {\n    this.device.disconnect();\n    this.connected = false;\n  }\n}\nclass FakeBluetoothRemoteGATTService {\n  constructor(device, characteristics) {\n    this.device = device;\n    this.characteristics = characteristics;\n    this.characteristics.service = this;\n  }\n  getCharacteristic(characteristic) {\n    return Promise.resolve(this.characteristics[characteristic]);\n  }\n}\nclass FakeBluetoothRemoteGATTCharacteristic {\n  constructor(properties, initialValue) {\n    this.listeners = {\n      characteristicvaluechanged: []\n    };\n    this.properties = properties;\n    this.value = initialValue;\n    this.initialValue = initialValue;\n  }\n  readValue() {\n    return Promise.resolve(this.value);\n  }\n  addEventListener(type, listener) {\n    this.listeners[type] = [...this.listeners[type], listener];\n  }\n  changeValue(value) {\n    this.value = value;\n    const mockedEvent = {\n      target: this\n    };\n    this.listeners.characteristicvaluechanged.forEach(listener => listener(mockedEvent));\n  }\n  clear() {\n    this.value = this.initialValue;\n    this.listeners = {\n      characteristicvaluechanged: []\n    };\n  }\n}\n\n/*\n * Public API Surface of angular-web-bluetooth\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BluetoothCore, BrowserWebBluetooth, ConsoleLoggerService, FakeBluetoothDevice, FakeBluetoothRemoteGATTCharacteristic, FakeBluetoothRemoteGATTServer, FakeBluetoothRemoteGATTService, NoLoggerService, ServerWebBluetooth, TI_SENSORAG_SERVICES, TiTag, WebBluetoothModule, browserWebBluetooth, consoleLoggerServiceConfig, makeMeTokenInjector };\n//# sourceMappingURL=manekinekko-angular-web-bluetooth.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}